# Signal Correlation for Kubernetes and Beyond

**⚠ Warning: Experimental ⚠**: This code may change without warning.

## Overview ##

Korrel8r is a *correlation engine* that follows relationships to find related data in multiple heterogeneous stores.

Korrel8r uses a set of *rules* that describe relationships between *objects* and *signals*. 
Given a *start* object (e.g. an Alert in a cluster) and a *goal* (e.g. "find related logs") the engine searches 
for goal data that is related to the start object some chain of rules.

The set of rules captures expert knowledge about troubleshooting in an executable form.
The engine aims to provide common rule-base that can be re-used in many settings:
as a service, embedded in graphical consoles or command line tools, or in offline data-processing systems.

The goals of this project include:

- Encode domain knowledge from SREs and other experts as re-usable rules.
- Automate navigation from symptoms to data that helps diagnose causes.
- Reduce multiple-step manual procedures to fewer clicks or queries.
- Help tools that gather and analyze diagnostic data to focus on relevant information.
- Bring together data that is held in different types of store.

There is a short [video demo](demos/openshift-console-browser/video.mov)

## Signals and Objects ##

A Kubernetes cluster generates many types of *observable signal*, including:

| Signal Type       | Description                                                             |
|-------------------|-------------------------------------------------------------------------|
| Metrics           | Counts and measurements of system behaviour.                            |
| Alerts            | Rules that fire when metrics cross important thresholds.                |
| Logs              | Application, infrastructure and audit logs from Pods and cluster nodes. |
| Kubernetes Events | Describe significant events in a cluster.                               |
| Traces            | Nested execution spans describing distributed requests.                 |
| Network Events    | TCP and IP level network information.                                   |

A cluster also contains objects that are not usually considered "signals",
but which can be correlated with signals and other objects:

| Object Type   | Description                                    |
|---------------|------------------------------------------------|
| k8s resources | Spec and status information.                   |
| Run books     | Problem solving guides associated with Alerts. |
| k8s probes    | Information about resource state.              |
| Operators     | Operators control other resources.             |

Korrel8r uses the term "object" generically to refer to signals and objects.

## Implentation Concepts ##

The following concepts are represented by interfaces in the korrel8r package.
These interfaces are implemented for each distinct type of signal and store.

**Domain** \
A family of signals or objects with common storage and representation.
Examples: k8s (resource), alert, metric, log, trace

**Store** \
A source of signal data from some Domain.
Examples: Loki, Prometheus, Kubernetes API server.

**Query**  \
A Query selects a set of signals from a store.
Queries are expressed as JSON objects and generated by rule templates.
The fields and values in a query depend on the type of store it will be used with.

**Class**  \
A subset of signals in a Domain with a common schema (the same field definitions).
Examples: `Pod.k8s`, `audit.log`

**Object** \
An instance of a signal or other correlation object.

**Rule**  \
A Rule applies to an instance of a *start* Class, and generates queries for a *goal* Class.
Rules are written in terms of domain-specific objects and query languages.
The start and goal of a rule can be in different domains (e.g. Pod.k8s → application.log)
Rules are defined using Go templates, see ./rules for examples.

## Conflicting Vocabularies ##

Different signal and object domains may use different vocabularies to identify the same things.
For example:

- `k8s.pod.name` (trace)
- `pod` or `pod_name` (metric)
- `kubernetes.pod_name` (log)

The correlation problem would be simpler if there was a single vocabulary to describe signal attributes.
The [Open Telemetry Project](https://opentelemetry.io/) aims to create such a standard vocabulary.
Unfortunately, at least for now, multiple vocabularies are embedded in existing systems.

A single vocabulary may eventually become universal, but in the short to medium term we have to handle mixed signals.
Korrel8r expresses rules in the native vocabulary of each domain, but allows rules to cross domains.

## Quick Start ##

Set up your cluster; there are scripts and examples to help in:
- [hack/openshift](hack/openshift/README.md) for OpenShift clusters.
- [hack/kind](hack/kind/README.md) for Kind clusters.

Log into your cluster as `kubeadmin` or other admin user.

You can install and run korrel8r on your local host:

```bash
go install github.com/korrel8r/korrel8r/cmd/korrel8r@latest
korrel8r web -http :8080 &
xdg-open http://localhost:8080
```

Or you can deploy the latest tagged image to your cluster as a deployment in namespace `korrel8r`

```bash
git clone git@github.com:korrel8r/korrel8r.git
cd korrel8r
make deploy TAG=latest
xdg-open $(make route-url)
```

With korrel8r running, you can browse the following URLs:

If running on the local host:
- http://localhost:8080     # Interactive browser interface.
- http://localhost:8080/api # REST API documentation

If deployed to the cluster, you can get the base URL for korrel8r with `make route-url`
(Note this requires an openshift cluster to expose a route to the korrel8r service)

## Developer Start

If you are interested in developing korrel8r see also [README-DEV.md](README-DEV.md)

