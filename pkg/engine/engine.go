// package engine implements generic correlation logic to correlate across domains.
package engine

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"github.com/korrel8r/korrel8r/internal/pkg/logging"
	"github.com/korrel8r/korrel8r/pkg/graph"
	"github.com/korrel8r/korrel8r/pkg/korrel8r"
	"golang.org/x/exp/maps"
)

var log = logging.Log()

// Engine combines a set of domains and a set of rules, so it can perform correlation.
type Engine struct {
	stores        map[string]korrel8r.Store
	domains       map[string]korrel8r.Domain
	rules         []korrel8r.Rule
	classes       []korrel8r.Class
	graph         *graph.Graph
	graphOnce     sync.Once
	templateFuncs map[string]any
}

func New() *Engine {
	return &Engine{
		stores:        map[string]korrel8r.Store{},
		domains:       map[string]korrel8r.Domain{},
		templateFuncs: map[string]any{},
	}
}

// Domain returns the named domain or nil if not found.
func (e *Engine) Domain(name string) korrel8r.Domain { return e.domains[name] }
func (e *Engine) DomainErr(name string) (korrel8r.Domain, error) {
	if d := e.Domain(name); d != nil {
		return d, nil
	}
	return nil, fmt.Errorf("domain not found: %v", name)
}

// Domains returns a list of known domains.
func (e *Engine) Domains() (domains []korrel8r.Domain) { return maps.Values(e.domains) }

// Store returns the default store for domain, or nil if not found.
func (e *Engine) Store(name string) korrel8r.Store { return e.stores[name] }
func (e *Engine) StoreErr(name string) (korrel8r.Store, error) {
	if s := e.Store(name); s != nil {
		return s, nil
	}
	return nil, fmt.Errorf("store not found: %v", name)
}

// TemplateFuncser can be implemented by Domain or Store implementations to contribute
// domain-specific template functions to template rules generated by the Engine.
// See text/template.Template.Funcs for details.
type TemplateFuncser interface{ TemplateFuncs() map[string]any }

// AddDomain domain and corresponding store, store may be nil.
func (e *Engine) AddDomain(d korrel8r.Domain, s korrel8r.Store) {
	e.domains[d.String()] = d
	if s != nil {
		e.stores[d.String()] = s
	}
	// Stores and Domains implement TemplateFuncser if they provide template helper functions
	// for use by rules.
	for _, v := range []any{d, s} {
		if tf, ok := v.(TemplateFuncser); ok {
			maps.Copy(e.templateFuncs, tf.TemplateFuncs())
		}
	}
}

// Class parses a full 'domain/class' name and returns the class.
func (e *Engine) Class(name string) (korrel8r.Class, error) {
	d, c, ok := strings.Cut(name, "/")
	if !ok || c == "" || d == "" {
		return nil, fmt.Errorf("invalid class name: %v", name)
	}
	domain, err := e.DomainErr(d)
	if err != nil {
		return nil, err
	}
	class := domain.Class(c)
	if class == nil {
		return nil, fmt.Errorf("unknown class in domain %v: %v", d, c)
	}
	return class, nil
}

func (e *Engine) Rules() []korrel8r.Rule { return e.rules }

func (e *Engine) AddRule(r korrel8r.Rule) error {
	e.rules = append(e.rules, r)
	return nil
}

func (e *Engine) AddRules(rules ...korrel8r.Rule) error {
	for _, r := range rules {
		if err := e.AddRule(r); err != nil {
			return err
		}
	}
	return nil
}

// Follow rules in a multi-path, collect results. Failure to apply a rule is not an error.
// Following errors are logged but not returned.
func (e *Engine) Follow(ctx context.Context, starters []korrel8r.Object, c *korrel8r.Constraint, path graph.MultiPath, results *Results) {
	log.V(4).Info("follow", "path", path, "starters", len(starters))
	for i, links := range path {
		log.V(4).Info("follow", "links", links)
		result := results.Get(links.Goal()) // Accumulated results for the search
		store, err := e.StoreErr(links.Goal().Domain().String())
		if err != nil {
			log.V(4).Error(err, "no store", "goal", korrel8r.ClassName(links.Goal()))
			result.Errors.Add(fmt.Sprintf("no goal store for %v", korrel8r.ClassName(links.Goal())))
			if i < len(path)-1 { // Don't skip the last links even with no store.
				continue
			}
		}
		stage := korrel8r.NewResult(links.Goal()) // Objects found at this stage of the search
		for _, rule := range links {
			for _, s := range starters {
				q, err := rule.Apply(s, c)
				if err != nil {
					log.V(4).Error(err, "did not apply", "rule", rule)
					result.Errors.Add(err.Error())
					continue
				}
				if result.Queries.Add(q) {
					log.V(4).Info("new query", "query", logging.JSON(q), "objects", len(stage.List()))
					result.Rules = append(result.Rules, rule)
				}
				if store == nil {
					continue
				}
				if err := store.Get(ctx, q, stage); err != nil {
					log.V(4).Error(err, "query failed", "query", q, "store", store.Domain())
					result.Errors.Add(err.Error())
					continue
				}
			}
		}
		starters = stage.List()
		result.Objects.Append(starters...)
		if len(starters) == 0 || i == len(path)-1 { // Cannot continue
			return
		}
	}
}

// FollowAll collects results from following multiple rule paths.
// Following errors are logged but not returned.
func (e *Engine) FollowAll(ctx context.Context, starters []korrel8r.Object, c *korrel8r.Constraint, paths []graph.MultiPath, results *Results) {
	// TODO: can we optimize multiple paths using topological sorting?
	for _, p := range paths {
		e.Follow(ctx, starters, nil, p, results)
	}
}

// Graph computes the rule graph from e.Rules and e.Classes on the first call.
// On subsequent calls it returns the same graph, it is not re-computed.
func (e *Engine) Graph() *graph.Graph {
	e.graphOnce.Do(func() {
		e.graph = graph.New("korrel8r", e.rules, e.classes...)
	})
	return e.graph
}

// TemplateFuncs returns template helper functions for stores and domains known to this engine.
// See text/template.Template.Funcs
func (e *Engine) TemplateFuncs() map[string]any { return e.templateFuncs }
